"""
test_html_output_validation.py

Additional validation tests for the HTML output generated by cpp2html.xsl.
Focuses on HTML structure, accessibility, and content validation.
"""

import re
import sys
from pathlib import Path
from html.parser import HTMLParser


class HTMLStructureValidator(HTMLParser):
    """Custom HTML parser to validate structure."""
    
    def __init__(self):
        super().__init__()
        self.tags = []
        self.errors = []
        self.table_count = 0
        self.has_org_type_header = False
        self.org_type_case_correct = False
        
    def handle_starttag(self, tag, attrs):
        self.tags.append(tag)
        if tag == 'table':
            self.table_count += 1
            
    def handle_data(self, data):
        stripped = data.strip()
        if 'Organisation Type' in stripped:
            self.has_org_type_header = True
            self.org_type_case_correct = True
        elif 'Organisation type' in stripped:
            self.has_org_type_header = True
            self.org_type_case_correct = False


class TestHTMLOutput:
    """Test suite for HTML output validation."""
    
    def __init__(self):
        self.repo_root = Path(__file__).parent.parent.parent
        self.test_results = []
        
    def log_result(self, test_name, passed, message=""):
        """Log test result."""
        status = "PASS" if passed else "FAIL"
        result = f"[{status}] {test_name}"
        if message:
            result += f": {message}"
        self.test_results.append((passed, result))
        print(result)
    
    def test_html_files_exist(self):
        """Test that HTML output files exist."""
        test_name = "HTML output files exist"
        html_files = list(self.repo_root.glob("CPP-*/cpp-*.html"))
        
        passed = len(html_files) > 0
        message = f"Found {len(html_files)} HTML files"
        self.log_result(test_name, passed, message)
        return passed
    
    def test_html_valid_structure(self):
        """Test HTML files have valid structure."""
        test_name = "HTML valid structure"
        html_files = list(self.repo_root.glob("CPP-*/cpp-*.html"))
        
        if not html_files:
            self.log_result(test_name, True, "SKIPPED - no HTML files")
            return True
        
        all_valid = True
        for html_file in html_files[:3]:  # Test first 3 files
            try:
                with open(html_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Basic structure checks
                has_doctype = content.strip().startswith('<!DOCTYPE')
                has_html_tag = '<html' in content.lower()
                has_head = '<head>' in content or '<head ' in content
                has_body = '<body>' in content or '<body ' in content
                has_closing_html = '</html>' in content
                
                if not all([has_doctype, has_html_tag, has_head, has_body, has_closing_html]):
                    all_valid = False
                    
            except Exception as e:
                all_valid = False
                print(f"  Error reading {html_file.name}: {e}")
        
        self.log_result(test_name, all_valid)
        return all_valid
    
    def test_organisation_type_in_output(self):
        """Test that 'Organisation Type' appears in HTML output with correct capitalization."""
        test_name = "Organisation Type in HTML output"
        html_files = list(self.repo_root.glob("CPP-*/cpp-*.html"))
        
        if not html_files:
            self.log_result(test_name, True, "SKIPPED - no HTML files")
            return True
        
        files_with_correct_cap = 0
        files_with_incorrect_cap = 0
        files_checked = 0
        
        for html_file in html_files:
            try:
                with open(html_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                has_correct = 'Organisation Type' in content
                has_incorrect = 'Organisation type' in content
                
                if has_correct:
                    files_with_correct_cap += 1
                if has_incorrect:
                    files_with_incorrect_cap += 1
                
                files_checked += 1
                
            except Exception as e:
                print(f"  Error reading {html_file.name}: {e}")
        
        # All files should have correct capitalization, none should have incorrect
        passed = files_with_incorrect_cap == 0 and files_with_correct_cap > 0
        message = f"Correct: {files_with_correct_cap}/{files_checked}, Incorrect: {files_with_incorrect_cap}"
        self.log_result(test_name, passed, message)
        return passed
    
    def test_html_table_structure(self):
        """Test that HTML tables have proper structure."""
        test_name = "HTML table structure"
        html_files = list(self.repo_root.glob("CPP-*/cpp-*.html"))
        
        if not html_files:
            self.log_result(test_name, True, "SKIPPED - no HTML files")
            return True
        
        all_valid = True
        for html_file in html_files[:2]:  # Test first 2 files
            try:
                with open(html_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Check for proper table structure
                has_table = '<table' in content
                has_thead_or_th = '<thead>' in content or '<th>' in content or '<th ' in content
                has_tr = '<tr>' in content or '<tr ' in content
                has_td = '<td>' in content or '<td ' in content
                
                if not all([has_table, has_thead_or_th, has_tr, has_td]):
                    all_valid = False
                    
            except Exception as e:
                all_valid = False
                print(f"  Error checking {html_file.name}: {e}")
        
        self.log_result(test_name, all_valid)
        return all_valid
    
    def test_css_styles_in_output(self):
        """Test that CSS styles are embedded in HTML output."""
        test_name = "CSS styles in HTML output"
        html_files = list(self.repo_root.glob("CPP-*/cpp-*.html"))
        
        if not html_files:
            self.log_result(test_name, True, "SKIPPED - no HTML files")
            return True
        
        # Check first HTML file
        try:
            with open(html_files[0], 'r', encoding='utf-8') as f:
                content = f.read()
            
            has_style_tag = '<style' in content.lower()
            has_css_rules = '{' in content and '}' in content
            has_table_style = 'table' in content.lower() and 'border' in content.lower()
            
            passed = has_style_tag and has_css_rules and has_table_style
            self.log_result(test_name, passed)
            return passed
            
        except Exception as e:
            self.log_result(test_name, False, str(e))
            return False
    
    def test_html_encoding(self):
        """Test that HTML files have proper UTF-8 encoding declaration."""
        test_name = "HTML UTF-8 encoding"
        html_files = list(self.repo_root.glob("CPP-*/cpp-*.html"))
        
        if not html_files:
            self.log_result(test_name, True, "SKIPPED - no HTML files")
            return True
        
        all_have_encoding = True
        for html_file in html_files[:3]:
            try:
                with open(html_file, 'r', encoding='utf-8') as f:
                    # Read first 1000 chars to check meta tags
                    content = f.read(1000)
                
                has_charset = 'charset=' in content.lower() or 'utf-8' in content.lower()
                if not has_charset:
                    all_have_encoding = False
                    
            except UnicodeDecodeError:
                all_have_encoding = False
            except Exception as e:
                print(f"  Error checking {html_file.name}: {e}")
        
        self.log_result(test_name, all_have_encoding)
        return all_have_encoding
    
    def test_table_headers_accessibility(self):
        """Test that table headers use proper th elements for accessibility."""
        test_name = "Table headers accessibility"
        html_files = list(self.repo_root.glob("CPP-*/cpp-*.html"))
        
        if not html_files:
            self.log_result(test_name, True, "SKIPPED - no HTML files")
            return True
        
        try:
            with open(html_files[0], 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Count th elements
            th_count = content.count('<th')
            
            # Should have multiple th elements for proper accessibility
            passed = th_count >= 4  # At least the 4 columns in public documentation table
            message = f"Found {th_count} <th> elements"
            self.log_result(test_name, passed, message)
            return passed
            
        except Exception as e:
            self.log_result(test_name, False, str(e))
            return False
    
    def test_html_links_format(self):
        """Test that hyperlinks are properly formatted in HTML."""
        test_name = "HTML links format"
        html_files = list(self.repo_root.glob("CPP-*/cpp-*.html"))
        
        if not html_files:
            self.log_result(test_name, True, "SKIPPED - no HTML files")
            return True
        
        try:
            with open(html_files[0], 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Check for anchor tags
            has_links = '<a ' in content.lower()
            has_href = 'href=' in content.lower()
            
            # Check that links close properly
            link_pattern = r'<a\s+[^>]*href=["\'][^"\']*["\'][^>]*>.*?</a>'
            link_matches = re.findall(link_pattern, content, re.DOTALL | re.IGNORECASE)
            
            passed = has_links and has_href and len(link_matches) > 0
            message = f"Found {len(link_matches)} properly formatted links"
            self.log_result(test_name, passed, message)
            return passed
            
        except Exception as e:
            self.log_result(test_name, False, str(e))
            return False
    
    def test_no_broken_html_tags(self):
        """Test that HTML doesn't have obviously broken tags."""
        test_name = "No broken HTML tags"
        html_files = list(self.repo_root.glob("CPP-*/cpp-*.html"))
        
        if not html_files:
            self.log_result(test_name, True, "SKIPPED - no HTML files")
            return True
        
        all_clean = True
        for html_file in html_files[:2]:
            try:
                with open(html_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Check for common broken tag patterns
                has_unclosed_tags = re.search(r'<[a-z]+[^>]*(?<!</)$', content, re.MULTILINE)
                has_malformed_tags = '< /' in content or '</ ' in content
                
                if has_unclosed_tags or has_malformed_tags:
                    all_clean = False
                    
            except Exception as e:
                all_clean = False
                print(f"  Error checking {html_file.name}: {e}")
        
        self.log_result(test_name, all_clean)
        return all_clean
    
    def test_consistent_table_styling(self):
        """Test that tables have consistent styling across files."""
        test_name = "Consistent table styling"
        html_files = list(self.repo_root.glob("CPP-*/cpp-*.html"))
        
        if not html_files:
            self.log_result(test_name, True, "SKIPPED - no HTML files")
            return True
        
        table_classes = set()
        for html_file in html_files:
            try:
                with open(html_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Extract table classes
                class_pattern = r'<table\s+class="([^"]+)"'
                matches = re.findall(class_pattern, content)
                table_classes.update(matches)
                
            except Exception as e:
                print(f"  Error checking {html_file.name}: {e}")
        
        # Should have consistent table classes across files
        has_public_doc_class = 'publicDocumentation' in table_classes
        passed = has_public_doc_class
        message = f"Found table classes: {', '.join(sorted(table_classes))}"
        self.log_result(test_name, passed, message)
        return passed
    
    def run_all_tests(self):
        """Run all HTML validation tests."""
        print("=" * 70)
        print("Running HTML Output Validation Test Suite")
        print("=" * 70)
        print()
        
        test_methods = [
            self.test_html_files_exist,
            self.test_html_valid_structure,
            self.test_organisation_type_in_output,
            self.test_html_table_structure,
            self.test_css_styles_in_output,
            self.test_html_encoding,
            self.test_table_headers_accessibility,
            self.test_html_links_format,
            self.test_no_broken_html_tags,
            self.test_consistent_table_styling,
        ]
        
        for test_method in test_methods:
            test_method()
            print()
        
        # Summary
        print("=" * 70)
        print("Test Summary")
        print("=" * 70)
        
        passed_count = sum(1 for passed, _ in self.test_results if passed)
        total_count = len(self.test_results)
        failed_count = total_count - passed_count
        
        print(f"\nTotal Tests: {total_count}")
        print(f"Passed: {passed_count}")
        print(f"Failed: {failed_count}")
        
        if failed_count > 0:
            print("\nFailed Tests:")
            for passed, result in self.test_results:
                if not passed:
                    print(f"  {result}")
        
        print()
        success_rate = (passed_count / total_count * 100) if total_count > 0 else 0
        print(f"Success Rate: {success_rate:.1f}%")
        print("=" * 70)
        
        return failed_count == 0


def main():
    """Main entry point."""
    tester = TestHTMLOutput()
    success = tester.run_all_tests()
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()